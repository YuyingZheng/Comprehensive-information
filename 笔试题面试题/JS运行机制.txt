
js整体代码的运行分为两个阶段：
1.编译器编译生成可执行代码阶段
    词法分析
    语法分析
    作用域规则确定
    可执行代码生成
2.js引擎运行可执行代码阶段
    执行上下文创建
    代码执行
    垃圾回收

栈stack：先进后出，后进先出
堆heap：无序的key-value数据
队列queue：先进先出FIFO
自动内存回收机制(引用计数法)

基础数据类型：
Undefined Null Boolean
String Number Symbol
按值访问
引用数据类型：
Array Object Function
按引用访问

函数调用栈Execution Context Stack：
用于处理执行上下文的运行顺序
栈底永远都是全局上下文
栈顶就是当前正在执行的上下文
栈顶的上下文执行完毕之后，就会自动出栈
全局上下文只有唯一的一个，它在浏览器关闭时出栈
执行上下文的个数没有限制

执行上下文Execution Context：
指当前代码的执行环境
全局上下文：js代码一运行就会产生
函数上下文：函数被调用就会产生
上下文产生后会进入到函数调用栈里，
等到执行完后，会自动弹出函数调用栈

执行上下文的生命周期：
    1.创建阶段
        生成变量对象
        建立作用域链
        确定this指向
    2.代码执行阶段
        变量赋值
        函数引用
        执行其他代码
    在创建阶段完成时入栈，
    在代码执行完成后出栈，
    最后等待垃圾回收处理。

变量对象Variable Object
用于存储基础数据类型
变量对象的创建过程：
    1.建立arguments对象。
        检查当前上下文中的参数，
        建立该对象下的属性与属性值。
    2.检查当前上下文的函数声明，
        也就是使用function关键字声明的函数。
        在变量对象中以函数名建立一个属性，
        属性值为指向该函数所在内存地址的引用。
        如果函数名的属性已经存在，
        那么该属性将会被新的引用所覆盖。
    3.检查当前上下文中的变量声明，
        每找到一个变量声明，
        就在变量对象中以变量名建立一个属性，
        属性值为undefined。
        如果该变量名的属性已经存在，
        为了防止同名的函数被修改为undefined，
        则会直接跳过，原属性值不会被修改。
未进入执行阶段之前，变量对象中的属性都不能访问！
但是进入执行阶段之后，变量对象转变为了活动对象，
里面的属性都能被访问了。
变量对象和活动对象是同一个对象，
只是处于执行上下文的不同生命周期。
不过只有处于函数调用栈栈顶的执行
上下文中的变量对象，才会变成活动对象。
全局上下文的变量对象就是window对象。

作用域Scope
我们把作用域定义为一套规则,
这套规则用来管理引擎如何在
当前作用域以及嵌套的子作用
域中根据变量名或者函数名进
行变量查找。
js中只有全局作用域与函数作用域
作用域与执行上下文是完全不同的两个概念
作用域链ScopeChain
作用域链，是由当前环境与上层环境
的一系列变量对象组成的单向通道，
它保证了当前执行环境对符合访问权
限的变量和函数的有序访问。
闭包Closure
闭包是一种特殊的对象。
它由两部分组成。执行上下文(代号A)，
以及在该执行上下文中创建的函数（代号B）。
当B执行时，如果访问了A中变量对象中的值，
那么闭包就会产生。
在大多数理解中，都以函数B的名字代指这里
生成的闭包。而在chrome中，则以执行上下
文A的函数名代指闭包。
闭包会阻止自动垃圾回收，容易造成内存泄露
需通过设置null进行手动释放内存
this指向
this的指向，是在函数被调用的时候确定的，
也就是执行上下文被创建时确定的。
在函数执行过程中，this一旦被确定，
就不可更改了。
全局上下文的this指向window。
类Class/对象Object
构造函数Constructor
与普通函数相比，构造函数并没有任何特别的地方，
首字母大写只是我们约定的小规定，
用于区分普通函数；
new关键字让构造函数具有了与普通函数不同的
许多特点，而new的过程中，执行了如下过程：
    1.声明一个中间对象；
    2.将该中间对象的原型指向构造函数的原型；
    3.将构造函数的this，指向该中间对象；
    4.返回该中间对象，即返回实例对象。
原型Prototype
每一个构造函数都可以有一个prototype属性，
该属性指向一个对象，这个对象就是原型。
我们可以将一些属性和方法通过prototype属性，
挂载在原型对象上。
而每一个new出来的实例，
都有一个__proto__属性，
该属性指向构造函数的原型对象，
通过这个属性，
让实例对象也能够访问原型对象上的方法和属性。
原型对象的方法与属性就变成了共有方法与属性。
当我们访问实例对象中的属性或者方法时，
会优先访问实例对象自身的属性和方法。
原型链PrototypeChain
我们知道所有的函数都有一个叫做toString
的方法，那么这个方法到底是在哪里的呢？
先随意声明一个函数：function add() {}。
函数add是Function对象的实例。
而Function的原型对象同时又是Object原型的实例。
这样就构成了一条原型链。
原型链的访问，其实跟作用域链有很大的相似之处，
他们都是一次单向的查找过程。
因此实例对象能够通过原型链，
访问到处于原型链上对象的所有属性与方法。
这也是add最终能够访问到处于Object
原型对象上的toString方法的原因。
继承Extend
基于原型链的特性，我们可以很轻松的实现继承。
结合构造函数与原型来创建一个对象：
    function Parent(){}
    function Child(){
        Parent.call(this);
    }
    Child.prototype = Object.create(Parent.prototype);
    Child.prototype.constructor = Child;
对象的属性类型：
在ECMAScript5中，
对每个属性都添加了几个属性类型，
来描述这些属性的特点。
他们分别是：
    configurable: 
        表示该属性是否能被delete删除。
        当其值为false时，
        其他的特性也不能被改变。
        默认值为true
    enumerable: 
        是否能枚举。
        也就是是否能被for-in遍历。
        默认值为true
    writable: 
        是否能修改值。
        默认为true
    value: 
        该属性的具体值是多少。
        默认为undefined
    get: 
        当我们通过person.name
        访问name的值时，
        get将被调用。
        该方法可以自定义返回的具体值时多少。
        get默认值为undefined
    set: 
        当我们通过person.name = 'Jake'
        设置name的值时，
        set方法将被调用。
        该方法可以自定义设置值的具体方式。
        set默认值为undefined
通过Object.defineProperty方法来修改
单个属性的属性类型。
通过Object.defineProperties方法来修改
多个属性的属性类型。
通过Object.getOwnPropertyDescriptor方法
读取某一个属性的属性类型。
事件循环EventLoop
事件循环机制从整体上的告诉了我们所写的JS代码
的执行顺序。
1.JS是单线程运行的，这个线程中拥有唯一的一个
  事件循环。
2.JS代码的执行过程中，除了依靠函数调用
栈来处理上下文的执行顺序外，还依靠
任务队列(task queue)来处理一些异步任务
的执行顺序。
3.一个线程中，事件循环是唯一的，但是任务
队列可以拥有多个。
4.任务队列又分为macro-task（宏任务）
与micro-task（微任务）。
5.macro-task大概包括：
    script(整体代码), 
    setTimeout, setInterval, 
    setImmediate, I/O,
    UI rendering。
6.micro-task大概包括: 
    process.nextTick, 
    Promise.then,
    MutationObserver(html5新特性)
7.setTimeout/Promise等我们称之为任务源，
  而进入任务队列的是他们指定的具体执行任务。
  setTimeout作为一个任务分发器，
  这个函数会立即执行，而它所要分发的任务，
  也就是它的第一个参数，才是延迟执行的任务。
8.来自不同任务源的任务会进入到不同的任务队列。
  其中setTimeout与setInterval是同源的。
9.事件循环的顺序，决定了JavaScript代码的
  执行顺序。它从script(整体代码)开始第一次
  循环。之后全局上下文进入函数调用栈。直到调
  用栈清空(只剩全局)，然后执行所有的
  micro-task。当所有可执行的micro-task执
  行完毕之后。循环再次从macro-task开始，
  找到其中一个任务队列执行完毕，
  然后再执行所有的micro-task，这样一直循环
  下去。其中每一个任务的执行，无论是
  macro-task还是micro-task，都是借助函数
  调用栈来完成。

-----------

Flux：
它是建立web客户端应用的前端架构，
是一种单向数据流思想
它的结构：
    Action
    Dispatcher
    Store
    View
它的数据流：
    1.Action
    2.Dispatcher
    3.Store
    4.View
    1.Action
    ...







